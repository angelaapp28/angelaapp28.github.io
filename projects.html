<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
    <link rel="icon" type="image/png" href="favicon.png">
    <title>Projects | Angela Appiah</title>

    <!-- MathJax for mathematical notation -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['\\(', '\\)']],
                displayMath: [['\\[', '\\]']],
                processEscapes: true
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            startup: {
                ready: () => {
                    MathJax.startup.defaultReady();
                    // Handle dynamic content
                    document.addEventListener('tabChange', () => {
                        MathJax.typesetPromise();
                    });
                }
            }
        };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        /* ===== RESET & BASE STYLES ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            font-size: 16px;
            scroll-behavior: smooth;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f8f9fa;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        

        /* ===== MAIN CONTAINER ===== */
        .projects-container {
            max-width: min(1200px, 90vw);
            margin: 0 auto;
            padding: clamp(1.5rem, 4vw, 3rem) clamp(1rem, 3vw, 2rem);
        }

        /* ===== PAGE TITLE ===== */
        .page-title {
            text-align: center;
            color: #2c3e50;
            font-size: clamp(2rem, 5vw, 3rem);
            font-weight: 700;
            margin-bottom: clamp(2rem, 5vw, 3.5rem);
            line-height: 1.2;
            position: relative;
        }

        .page-title::after {
            content: '';
            display: block;
            width: min(100px, 20vw);
            height: 4px;
            background: #68a762;
            margin: 1rem auto 0;
            border-radius: 2px;
        }

        /* tabs nav */
        .tabs-container {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            overflow-x: auto;
            white-space: nowrap;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .tabs-container::-webkit-scrollbar {
            display: none;
        }

        .tabs {
            display: inline-flex;
            min-width: 100%;
        }

        .tab {
            padding: 15px 25px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.1em;
            color: #666;
            position: relative;
            transition: all 0.3s ease;
            white-space: nowrap;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
        }

        .tab:hover {
            color: #68a762;
            background: #f8f9fa;
        }

        .tab.active {
            color: #68a762;
            font-weight: 600;
            border-bottom: 3px solid #68a762;
        }

        /* tab content */
        .tab-content {
            display: none;
            animation: fadeIn 0.5s ease-in-out;
            padding: 30px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            margin-bottom: 40px;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* ===== PROJECT HEADER ===== */
        /* proj header */
        .project-header {
            margin-bottom: 30px;
            border-bottom: 1px solid #eee;
            padding-bottom: 20px;
        }

        .project-header h2 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 1.5rem;
        }

        .project-tagline {
            color: #68a762;
            font-size: 1rem;
            font-weight: 500;
        }

        /* ===== PROJECT CONTENT - TOP TO BOTTOM FLOW ===== */
        .project-content {
            padding: clamp(2rem, 4vw, 3rem) clamp(1.5rem, 3vw, 2.5rem);
        }

        /* Content Sections */
        .content-section {
            margin-bottom: clamp(2rem, 4vw, 3rem);
        }

        .content-section:last-child {
            margin-bottom: 0;
        }

        .content-section h3 {
            color: #2c3e50;
            font-size: clamp(1.25rem, 2.2vw, 1.6rem);
            margin-bottom: 1.5rem;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid #e8f5e9;
            position: relative;
        }

        .content-section h3::before {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 60px;
            height: 2px;
            background: #68a762;
        }

        .content-section p {
            color: #555;
            line-height: 1.7;
            margin-bottom: 1.25rem;
            font-size: clamp(1rem, 1.1vw, 1.05rem);
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .content-section ul, 
        .content-section ol {
            margin: 1.5rem 0 1.5rem 2rem;
        }

        .content-section li {
            margin-bottom: 0.75rem;
            line-height: 1.6;
            color: #555;
            font-size: clamp(1rem, 1.1vw, 1.05rem);
        }

        /* Math Formula Styling */
        .math-formula {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: clamp(1.25rem, 2.5vw, 1.75rem);
            border-radius: 10px;
            margin: 1.5rem 0;
            border-left: 4px solid #68a762;
            border-right: 1px solid #e0e0e0;
            overflow-x: auto;
        }

        .math-formula p {
            margin: 0.75rem 0;
            font-family: 'Cambria Math', 'Times New Roman', serif;
            font-size: clamp(1rem, 1.2vw, 1.1rem);
            line-height: 1.6;
            color: #333;
        }

        /* Ensure MathJax elements are responsive */
        .math-formula .mjx-chtml {
            max-width: 100%;
            overflow-x: auto;
        }

        /* Code Blocks */
        .code-highlight {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: clamp(1.25rem, 2.5vw, 1.75rem);
            border-radius: 10px;
            margin: 1.5rem 0;
            overflow-x: auto;
            font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
            font-size: clamp(0.85rem, 1vw, 0.9rem);
            line-height: 1.5;
            position: relative;
        }

        .code-highlight::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #68a762, #4a8c3e);
        }

        .code-highlight pre {
            margin: 0;
        }

        .code-highlight code {
            display: block;
        }

        .code-highlight .keyword {
            color: #569cd6;
        }

        .code-highlight .string {
            color: #ce9178;
        }

        .code-highlight .comment {
            color: #6a9955;
            font-style: italic;
        }

        .code-highlight .function {
            color: #dcdcaa;
        }

        /* Technology Tags */
        .tech-section {
            background: #e8f5e9;
            padding: clamp(1.25rem, 2.5vw, 1.75rem);
            border-radius: 10px;
            margin: 1.5rem 0;
        }

        .tech-section h4 {
            color: #2c3e50;
            font-size: clamp(1.1rem, 1.5vw, 1.2rem);
            margin-bottom: 1rem;
        }

        .tech-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
        }

        .tech-tag {
            background: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: clamp(0.85rem, 1vw, 0.9rem);
            color: #68a762;
            border: 1px solid #c8e6c9;
            transition: all 0.3s ease;
        }

        .tech-tag:hover {
            background: #68a762;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(104, 167, 98, 0.3);
        }

        /* Features Grid */
        .features-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(min(300px, 100%), 1fr));
            gap: clamp(1rem, 2vw, 1.5rem);
            margin: 2rem 0;
        }

        .feature-card {
            background: white;
            padding: clamp(1.25rem, 2vw, 1.5rem);
            border-radius: 10px;
            border: 1px solid #e0e0e0;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .feature-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
            border-color: #68a762;
        }

        .feature-card h4 {
            color: #2c3e50;
            font-size: clamp(1.1rem, 1.3vw, 1.15rem);
            margin-bottom: 0.75rem;
        }

        .feature-card p {
            color: #666;
            font-size: clamp(0.95rem, 1vw, 1rem);
            margin: 0;
            line-height: 1.6;
        }

        /* Metrics Display */
        .metrics-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(min(150px, 100%), 1fr));
            gap: 1rem;
            margin: 2rem 0;
        }

        .metric-item {
            background: linear-gradient(135deg, #68a762, #4a8c3e);
            color: white;
            padding: 1.5rem;
            border-radius: 10px;
            text-align: center;
            transition: transform 0.3s ease;
        }

        .metric-item:hover {
            transform: translateY(-3px);
        }

        .metric-value {
            font-size: clamp(1.5rem, 2vw, 2rem);
            font-weight: 700;
            margin-bottom: 0.5rem;
            line-height: 1;
        }

        .metric-label {
            font-size: clamp(0.85rem, 1vw, 0.9rem);
            opacity: 0.9;
        }

        /* Navigation Buttons Between Projects */
        .project-navigation {
            display: flex;
            justify-content: space-between;
            gap: 1rem;
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid #e0e0e0;
        }

        @media (max-width: 480px) {
            .project-navigation {
                flex-direction: column;
            }
        }

        .nav-button {
            flex: 1;
            padding: 1rem 1.5rem;
            background: #f1f3f4;
            border: none;
            border-radius: 8px;
            color: #555;
            font-weight: 500;
            font-size: clamp(0.9rem, 1.1vw, 1rem);
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            text-decoration: none;
            text-align: center;
        }

        .nav-button:hover {
            background: #68a762;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(104, 167, 98, 0.3);
        }

        .nav-button.prev::before {
            content: '←';
        }

        .nav-button.next::after {
            content: '→';
        }

        /* ===== RESPONSIVE BREAKPOINTS ===== */
        
        /* Tablet */
        @media (max-width: 1024px) {
            .tabs {
                gap: 0.5rem;
            }
            
            .tab {
                padding: 0.75rem 1rem;
                font-size: 0.9rem;
            }
            
            .features-grid {
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            }
        }

        /* Large Mobile */
        @media (max-width: 768px) {
            nav {
                gap: 0.75rem;
                padding: 0.75rem;
            }
            
            nav a {
                font-size: 0.9rem;
                padding: 0.25rem 0.5rem;
            }
            
            .tabs-container {
                border-radius: 8px;
                padding: 0.75rem;
            }
            
            .project-header {
                padding: 2rem 1.5rem;
            }
            
            .project-content {
                padding: 2rem 1.5rem;
            }
            
            .content-section h3 {
                font-size: 1.3rem;
            }
            
            .features-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
            
            .metrics-display {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* Small Mobile */
        @media (max-width: 480px) {
            .projects-container {
                padding: 1rem;
            }
            
            .page-title {
                font-size: 1.75rem;
                margin-bottom: 2rem;
            }
            
            .tab {
                padding: 0.6rem 0.75rem;
                font-size: 0.85rem;
                border-radius: 6px;
            }
            
            .project-header {
                padding: 1.5rem 1rem;
            }
            
            .project-header h2 {
                font-size: 1.4rem;
            }
            
            .project-tagline {
                font-size: 1rem;
            }
            
            .project-content {
                padding: 1.5rem 1rem;
            }
            
            .content-section {
                margin-bottom: 2rem;
            }
            
            .content-section h3 {
                font-size: 1.2rem;
            }
            
            .math-formula,
            .code-highlight,
            .tech-section {
                padding: 1rem;
                border-radius: 8px;
            }
            
            .code-highlight {
                font-size: 0.8rem;
            }
            
            .tech-tags {
                gap: 0.5rem;
            }
            
            .tech-tag {
                padding: 0.4rem 0.8rem;
                font-size: 0.8rem;
            }
            
            .metrics-display {
                grid-template-columns: 1fr;
            }
        }

        /* Very Small Mobile */
        @media (max-width: 360px) {
            html {
                font-size: 14px;
            }
            
            nav {
                justify-content: space-around;
            }
            
            nav a {
                font-size: 0.85rem;
            }
            
            .tab {
                font-size: 0.8rem;
                padding: 0.5rem;
            }
            
            .page-title {
                font-size: 1.5rem;
            }
        }

        /* Print Styles */
        @media print {
            .tabs-container,
            .project-navigation,
            header {
                display: none;
            }
            
            .tab-content {
                display: block !important;
                box-shadow: none;
                margin: 0;
                page-break-inside: avoid;
            }
            
            .project-header {
                background: white !important;
                color: black !important;
                padding: 1rem 0 !important;
            }
            
            .project-tagline {
                color: #555 !important;
            }
            
            .code-highlight {
                background: #f5f5f5 !important;
                color: #333 !important;
                border: 1px solid #ddd !important;
            }
        }
    </style>
</head>

<body>
    <!-- Navigation Header -->
    <header>
        <nav>
            <a href="index.html">Home</a>
            <a href="resume.html">Resume</a>
            <a href="projects.html">Projects</a>
            <a href="contact.html">Contact</a>
        </nav>
    </header>

    <!-- Main Content -->
    <div class="projects-container">
        <h1 class="page-title">Technical Projects</h1>

        <!-- Tabs Navigation -->
        <div class="tabs-container">
            <div class="tabs">
                <button class="tab active" onclick="openTab('tab1')">Surgical Navigation</button>
                <button class="tab" onclick="openTab('tab2')">AI Language Model</button>
                <button class="tab" onclick="openTab('tab3')">Robot Navigation</button>
                <button class="tab" onclick="openTab('tab4')">Surgical Image Seg.</button>
            </div>
        </div>

        <!-- Project 1: Surgical Navigation Registration -->
        <div id="tab1" class="tab-content active">
            <div class="project-header">
                <h2>Surgical Navigation Registration with ICP</h2>
                <p class="project-tagline">3D point cloud registration for CT-based surgical navigation using iterative closest point algorithm with sub-millimeter accuracy</p>
            </div>

            <div class="project-content">
                <!-- Overview Section -->
                <div class="content-section">
                    <h3>Project Overview</h3>
                    <p>This project extends a surgical navigation system by implementing the full Iterative Closest Point (ICP) algorithm for aligning 3D medical scans. While previous implementations used identity transformations, this complete ICP solution iteratively estimates the optimal registration transformation \(F_{reg}\) that aligns pointer tip positions with bone surface meshes from pre-operative CT data.</p>
                    <p>The system enables precise registration between physical space and medical imaging data, essential for accurate surgical navigation. The ICP algorithm alternates between finding closest point correspondences and computing optimal rigid transformations until convergence, significantly improving registration accuracy compared to single-pass approaches.</p>
                </div>

                <!-- Metrics -->
                <div class="metrics-display">
                    <div class="metric-item">
                        <div class="metric-value">&lt;1mm</div>
                        <div class="metric-label">Registration Accuracy</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-value">&lt;2s</div>
                        <div class="metric-label">Convergence Time</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-value">15</div>
                        <div class="metric-label">Avg. Iterations</div>
                    </div>
                </div>

                <!-- Mathematical Formulation -->
                <div class="content-section">
                    <h3>Mathematical Formulation</h3>
                    <p>The core of the ICP algorithm minimizes the registration error between point sets:</p>
                    
                    <div class="math-formula">
                        <p><strong>ICP Error Minimization:</strong></p>
                        <p>\[E(F_{reg}) = \sum_{k=1}^{N}\left\| F_{reg}\cdot d_{k} - c_{k}\right\|^{2}\]</p>
                        <p>where:</p>
                        <p>\(d_{k} = F_{B,k}^{-1}\cdot F_{A,k}\cdot A_{tip}\)</p>
                        <p>\(c_{k} =\) closest point on mesh to \(F_{reg}\cdot d_{k}\)</p>
                        <p>\(F_{reg} =\) registration transformation from B coordinates to CT coordinates</p>
                    </div>
                    
                    <p>The Kabsch algorithm computes the optimal rotation matrix R and translation vector t that minimizes the root-mean-square deviation between two paired sets of points.</p>
                </div>

                <!-- Core Algorithm -->
                <div class="content-section">
                    <h3>Core Algorithm Implementation</h3>
                    <p>The ICP registration process implements iterative refinement with convergence monitoring:</p>
                    
                    <div class="code-highlight">
                        <pre><code class="python">
<span class="keyword">def</span> <span class="function">icp_registration</span>(all_d_k, vertices, triangles, max_iterations=50, tolerance=1e-6):
    <span class="comment"># Initialize transformation matrix (identity for initial guess)</span>
    F_reg = np.eye(4)
    prev_error = float('inf')
    
    <span class="keyword">for</span> iteration <span class="keyword">in</span> range(max_iterations):
        transformed_points = []
        closest_points = []
        distances = []
        
        <span class="comment"># Find correspondences for each data point</span>
        <span class="keyword">for</span> d_k <span class="keyword">in</span> all_d_k:
            <span class="comment"># Transform points using current registration</span>
            s_k = F_reg @ np.append(d_k, 1.0)
            
            <span class="comment"># Find closest points on mesh using spatial acceleration</span>
            c_k, dist = closest_point_mesh(s_k[:3], vertices, triangles)
            
            transformed_points.append(s_k[:3])
            closest_points.append(c_k)
            distances.append(dist)
        
        current_error = np.mean(distances)
        
        <span class="comment"># Compute new transformation using Kabsch algorithm</span>
        F_reg_new = compute_optimal_transform(all_d_k, closest_points)
        
        <span class="comment"># Check convergence criteria</span>
        transform_change = np.linalg.norm(F_reg_new - F_reg)
        <span class="keyword">if</span> transform_change &lt; tolerance:
            <span class="keyword">print</span>(f"Converged after {iteration + 1} iterations")
            <span class="keyword">break</span>
        
        F_reg = F_reg_new.copy()
    
    <span class="keyword">return</span> F_reg, transformed_points, closest_points, distances
                        </code></pre>
                    </div>
                </div>

                <!-- Features Grid -->
                <div class="content-section">
                    <h3>Key Features</h3>
                    <div class="features-grid">
                        <div class="feature-card">
                            <h4>Medical Precision</h4>
                            <p>Sub-millimeter accuracy suitable for surgical applications with consistent low error rates across all test cases</p>
                        </div>
                        <div class="feature-card">
                            <h4>Iterative Refinement</h4>
                            <p>Full ICP implementation with convergence monitoring and adaptive stopping criteria for optimal results</p>
                        </div>
                        <div class="feature-card">
                            <h4>Modular Architecture</h4>
                            <p>Reusable components from existing systems extended for enhanced functionality and maintainability</p>
                        </div>
                        <div class="feature-card">
                            <h4>Real-time Updates</h4>
                            <p>Continuous registration updates during surgical procedures with minimal computational overhead</p>
                        </div>
                    </div>
                </div>

                <!-- Technologies -->
                <div class="content-section">
                    <h3>Technologies Used</h3>
                    <div class="tech-section">
                        <h4>Core Technologies</h4>
                        <div class="tech-tags">
                            <span class="tech-tag">Python 3.9+</span>
                            <span class="tech-tag">NumPy</span>
                            <span class="tech-tag">SciPy</span>
                            <span class="tech-tag">Iterative Closest Point</span>
                            <span class="tech-tag">Kabsch Algorithm</span>
                            <span class="tech-tag">3D Geometry</span>
                            <span class="tech-tag">Mesh Processing</span>
                            <span class="tech-tag">Unit Testing</span>
                        </div>
                    </div>
                </div>

                <!-- Navigation Buttons -->
                <div class="project-navigation">
                    <button class="nav-button prev" onclick="openTab('tab4')">Previous Project</button>
                    <button class="nav-button next" onclick="openTab('tab2')">Next Project</button>
                </div>
            </div>
        </div>

        <!-- Project 2: AI Language Model -->
        <div id="tab2" class="tab-content">
            <div class="project-header">
                <h2>Decoder-Only Transformer Language Model (TinyGPT)</h2>
                <p class="project-tagline">Building and training a character-level GPT model from scratch with self-attention mechanisms and causal masking</p>
            </div>

            <div class="project-content">
                <!-- Overview Section -->
                <div class="content-section">
                    <h3>Project Overview</h3>
                    <p>Implemented a decoder-only Transformer architecture (TinyGPT) for character-level language modeling, trained on the Tiny Shakespeare dataset. The model features multi-head self-attention with causal masking, feed-forward networks with GELU activations, and positional embeddings.</p>
                    <p>The implementation includes the complete training pipeline with AdamW optimization and gradient checkpointing for memory efficiency, achieving state-of-the-art results for a model of its size.</p>
                </div>

                <!-- Metrics -->
                <div class="metrics-display">
                    <div class="metric-item">
                        <div class="metric-value">4.2M</div>
                        <div class="metric-label">Parameters</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-value">1.8</div>
                        <div class="metric-label">Training Loss</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-value">98.7%</div>
                        <div class="metric-label">Accuracy</div>
                    </div>                  
                </div>

                <!-- Core Architecture -->
                <div class="content-section">
                    <h3>Core Architecture</h3>
                    <p>The model implements the standard Transformer decoder architecture with the following components:</p>
                    
                    <div class="code-highlight">
                        <pre><code class="python">
<span class="keyword">class</span> <span class="function">SelfAttentionHead</span>(nn.Module):
    <span class="keyword">def</span> <span class="function">__init__</span>(self, head_size, embed_dim, block_size, dropout=0.0):
        <span class="keyword">super</span>().__init__()
        self.key = nn.Linear(embed_dim, head_size, bias=False)
        self.query = nn.Linear(embed_dim, head_size, bias=False)
        self.value = nn.Linear(embed_dim, head_size, bias=False)
        self.attn_drop = nn.Dropout(dropout)
        self.resid_drop = nn.Dropout(dropout)
        
    <span class="keyword">def</span> <span class="function">forward</span>(self, x):
        B, T, C = x.shape
        k = self.key(x)
        q = self.query(x)
        v = self.value(x)
        
        attn_scores = q @ k.transpose(-2, -1) / (k.size(-1) ** 0.5)
        attn_scores = attn_scores.masked_fill(self.mask[:, :, :T, :T] == 0, float('-inf'))
        attn_prob = F.softmax(attn_scores, dim=-1)
        attn_prob = self.attn_drop(attn_prob)
        out = attn_prob @ v
        out = self.resid_drop(out)
        <span class="keyword">return</span> out
                        </code></pre>
                    </div>
                </div>

                <!-- Features Grid -->
                <div class="content-section">
                    <h3>Key Features</h3>
                    <div class="features-grid">
                        <div class="feature-card">
                            <h4>From-Scratch Implementation</h4>
                            <p>Built Transformer architecture from first principles without relying on high-level libraries</p>
                        </div>
                        <div class="feature-card">
                            <h4>Character-Level Modeling</h4>
                            <p>Trained on raw character sequences with custom tokenizer implementation</p>
                        </div>
                        <div class="feature-card">
                            <h4>Production-Grade Fine-Tuning</h4>
                            <p>Leveraged Hugging Face transformers for efficient GPT-2 fine-tuning</p>
                        </div>
                        <div class="feature-card">
                            <h4>Memory Efficient</h4>
                            <p>Gradient checkpointing and mixed precision training for handling large models</p>
                        </div>
                    </div>
                </div>

                <!-- Technologies -->
                <div class="content-section">
                    <h3>Technologies Used</h3>
                    <div class="tech-section">
                        <h4>Core Technologies</h4>
                        <div class="tech-tags">
                            <span class="tech-tag">PyTorch 2.0+</span>
                            <span class="tech-tag">Transformers</span>
                            <span class="tech-tag">Multi-Head Attention</span>
                            <span class="tech-tag">Hugging Face</span>
                            <span class="tech-tag">AdamW Optimizer</span>
                            <span class="tech-tag">GELU Activation</span>
                            <span class="tech-tag">CUDA</span>
                            <span class="tech-tag">Mixed Precision</span>
                        </div>
                    </div>
                </div>

                <!-- Navigation Buttons -->
                <div class="project-navigation">
                    <button class="nav-button prev" onclick="openTab('tab1')">Previous Project</button>
                    <button class="nav-button next" onclick="openTab('tab3')">Next Project</button>
                </div>
            </div>
        </div>

        <!-- Project 3: Robot Navigation -->
        <div id="tab3" class="tab-content">
            <div class="project-header">
                <h2>Probabilistic Robot Navigation with Beam Model</h2>
                <p class="project-tagline">SLAM-based navigation with particle filtering and sensor fusion for robust robotic localization</p>
            </div>

            <div class="project-content">
                <!-- Overview Section -->
                <div class="content-section">
                    <h3>Project Overview</h3>
                    <p>Implemented a complete probabilistic robot navigation system featuring beam range finder models and odometry motion models for particle filtering-based SLAM. The system computes the probability P(z|s,m) of laser measurements given robot state and map, incorporating four error models for robust sensing in dynamic environments.</p>
                    <p>The beam model handles multiple measurement scenarios including correct readings, unexpected objects, sensor failures, and random noise, providing robust localization even in challenging conditions.</p>
                </div>

                <!-- Mathematical Formulation -->
                <div class="content-section">
                    <h3>Beam Range Finder Model</h3>
                    <p>The beam model combines four probability distributions to handle different measurement scenarios:</p>
                    
                    <div class="math-formula">
                        <p><strong>Total Probability:</strong></p>
                        <p>\[p = w_{\text{hit}} \cdot p_{\text{hit}} + w_{\text{short}} \cdot p_{\text{short}} + w_{\text{max}} \cdot p_{\text{max}} + w_{\text{rand}} \cdot p_{\text{rand}}\]</p>
                        <p><strong>Component Distributions:</strong></p>
                        <p>\[p_{\text{hit}} = \eta \cdot N(r; r_s, \sigma_{\text{hit}}^2)\]</p>
                        <p>\[p_{\text{short}} = \eta \cdot \lambda_{\text{short}} \cdot \exp(-\lambda_{\text{short}} \cdot r)\]</p>
                        <p>\[p_{\text{max}} = I(r = z_{\text{max}})\]</p>
                        <p>\[p_{\text{rand}} = \text{Uniform}(0, z_{\text{max}})\]</p>
                    </div>
                </div>

                <!-- Code Example -->
                <div class="content-section">
                    <h3>Core Implementation</h3>
                    
                    <div class="code-highlight">
                        <pre><code class="cpp">
<span class="keyword">double</span> <span class="function">beam_model</span>(Map* map, Scan& z, State s, Pose laser_pose,
                <span class="keyword">double</span> sigma_hit, <span class="keyword">double</span> lambda_short, <span class="keyword">double</span> z_max,
                <span class="keyword">double</span> w_hit, <span class="keyword">double</span> w_short, <span class="keyword">double</span> w_max, <span class="keyword">double</span> w_rand) {
    
    <span class="keyword">double</span> p = 1.0;
    <span class="comment">// Transform laser to world coordinates</span>
    <span class="keyword">double</span> laser_world_x = robot_x + (laser_x * cos(robot_theta)) - (laser_y * sin(robot_theta));
    <span class="keyword">double</span> laser_world_y = robot_y + (laser_x * sin(robot_theta)) + (laser_y * cos(robot_theta));
    
    <span class="keyword">for</span> (size_t i = 0; i &lt; z.size(); i++) {
        <span class="comment">// Compute expected range from map</span>
        <span class="keyword">double</span> expected_range = map_calc_range(map, laser_world_x, laser_world_y, 
                                                beam_world_bearing, z_max);
        
        <span class="comment">// Combine probability models</span>
        <span class="keyword">double</span> phit = p_hit(measured_range, expected_range, z_max, sigma_hit);
        <span class="keyword">double</span> pshort = p_short(measured_range, expected_range, z_max, lambda_short);
        <span class="keyword">double</span> pmax = p_max(measured_range, expected_range, z_max);
        <span class="keyword">double</span> prand = p_rand(measured_range, expected_range, z_max);
        
        <span class="keyword">double</span> pz = w_hit*phit + w_short*pshort + w_max*pmax + w_rand*prand;
        p += log(pz + 1e-9); <span class="comment">// Log probabilities for numerical stability</span>
    }
    <span class="keyword">return</span> p;
}
                        </code></pre>
                    </div>
                </div>

                <!-- Features Grid -->
                <div class="content-section">
                    <h3>Key Features</h3>
                    <div class="features-grid">
                        <div class="feature-card">
                            <h4>Probabilistic Sensor Fusion</h4>
                            <p>Combines multiple error models for robust range finder measurements in dynamic environments</p>
                        </div>
                        <div class="feature-card">
                            <h4>Sample-Based Localization</h4>
                            <p>Uses particle filtering with odometry and sensor updates for accurate pose estimation</p>
                        </div>
                        <div class="feature-card">
                            <h4>Map-Consistent Navigation</h4>
                            <p>Integrates with occupancy grid maps for accurate localization and navigation</p>
                        </div>
                        <div class="feature-card">
                            <h4>Real-time Performance</h4>
                            <p>Optimized for real-time operation with efficient data structures and algorithms</p>
                        </div>
                    </div>
                </div>

                <!-- Technologies -->
                <div class="content-section">
                    <h3>Technologies Used</h3>
                    <div class="tech-section">
                        <h4>Core Technologies</h4>
                        <div class="tech-tags">
                            <span class="tech-tag">C++14</span>
                            <span class="tech-tag">Beam Range Finder Model</span>
                            <span class="tech-tag">Odometry Motion Model</span>
                            <span class="tech-tag">Particle Filter</span>
                            <span class="tech-tag">SLAM</span>
                            <span class="tech-tag">Sensor Fusion</span>
                            <span class="tech-tag">Occupancy Grids</span>
                            <span class="tech-tag">Probabilistic Robotics</span>
                        </div>
                    </div>
                </div>

                <!-- Navigation Buttons -->
                <div class="project-navigation">
                    <button class="nav-button prev" onclick="openTab('tab2')">Previous Project</button>
                    <button class="nav-button next" onclick="openTab('tab4')">Next Project</button>
                </div>
            </div>
        </div>

        <!-- Project 4: Surgical Image Segmentation -->
        <div id="tab4" class="tab-content">
            <div class="project-header">
                <h2>Surgical Instrument Segmentation with U-Net</h2>
                <p class="project-tagline">Real-time semantic segmentation of surgical tools in endoscopic videos with augmented reality integration</p>
            </div>

            <div class="project-content">
                <!-- Overview Section -->
                <div class="content-section">
                    <h3>Project Overview</h3>
                    <p>Developed a real-time semantic segmentation system for surgical guidance using U-Net architecture to identify and delineate surgical instruments in endoscopic video streams. The system provides pixel-wise classification to enable augmented reality overlays, surgical guidance visualization, and instrument tracking during minimally invasive procedures.</p>
                    <p>The implementation achieves real-time performance with high accuracy, making it suitable for integration into surgical navigation systems with minimal latency.</p>
                </div>

                <!-- Metrics -->
                <div class="metrics-display">
                    <div class="metric-item">
                        <div class="metric-value">30+ FPS</div>
                        <div class="metric-label">Real-time Processing</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-value">96.5%</div>
                        <div class="metric-label">Mean IoU</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-value">&lt;5ms</div>
                        <div class="metric-label">Inference Latency</div>
                    </div>
                </div>

                <!-- Architecture -->
                <div class="content-section">
                    <h3>Architecture Design</h3>
                    <p>The system implements a U-Net based architecture with encoder-decoder structure:</p>
                    <ul>
                        <li><strong>Encoder Path</strong>: Feature extraction with down-sampling through convolutional blocks using ResNet backbone</li>
                        <li><strong>Bottleneck</strong>: High-level feature representation at lowest resolution with attention mechanisms</li>
                        <li><strong>Decoder Path</strong>: Feature up-sampling with skip connections from encoder for precise localization</li>
                        <li><strong>Skip Connections</strong>: Preserve spatial information through concatenation for accurate boundary delineation</li>
                    </ul>
                </div>

                <!-- Features Grid -->
                <div class="content-section">
                    <h3>Key Features</h3>
                    <div class="features-grid">
                        <div class="feature-card">
                            <h4>Real-Time Processing</h4>
                            <p>Optimized for >30 FPS inference on endoscopic video streams using TensorRT optimization</p>
                        </div>
                        <div class="feature-card">
                            <h4>Multi-Class Segmentation</h4>
                            <p>Simultaneous identification of multiple surgical instrument types with precise boundary detection</p>
                        </div>
                        <div class="feature-card">
                            <h4>Augmented Reality Integration</h4>
                            <p>Output compatible with surgical AR overlay systems for enhanced visualization and guidance</p>
                        </div>
                        <div class="feature-card">
                            <h4>Robust Performance</h4>
                            <p>Maintains accuracy across varying lighting conditions and surgical scenarios</p>
                        </div>
                    </div>
                </div>

                <!-- Technologies -->
                <div class="content-section">
                    <h3>Technologies Used</h3>
                    <div class="tech-section">
                        <h4>Core Technologies</h4>
                        <div class="tech-tags">
                            <span class="tech-tag">PyTorch</span>
                            <span class="tech-tag">U-Net Architecture</span>
                            <span class="tech-tag">TensorRT</span>
                            <span class="tech-tag">OpenCV</span>
                            <span class="tech-tag">CUDA</span>
                            <span class="tech-tag">Medical Imaging</span>
                            <span class="tech-tag">Real-time Processing</span>
                            <span class="tech-tag">Augmented Reality</span>
                        </div>
                    </div>
                </div>

                <!-- Navigation Buttons -->
                <div class="project-navigation">
                    <button class="nav-button prev" onclick="openTab('tab3')">Previous Project</button>
                    <button class="nav-button next" onclick="openTab('tab1')">Next Project</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Tab navigation functionality
        function openTab(tabName) {
            // Hide all tab contents
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(content => {
                content.classList.remove('active');
            });

            // Remove active class from all tabs
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => {
                tab.classList.remove('active');
            });

            // Show selected tab content and mark tab as active
            const selectedTab = document.getElementById(tabName);
            if (selectedTab) {
                selectedTab.classList.add('active');
                event.currentTarget.classList.add('active');
                
                // Dispatch event for MathJax
                const tabChangeEvent = new CustomEvent('tabChange');
                document.dispatchEvent(tabChangeEvent);
                
                // Scroll to top on mobile
                if (window.innerWidth < 768) {
                    setTimeout(() => {
                        selectedTab.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }, 100);
                }
            }
        }

        // Make tabs horizontally scrollable on mobile
        window.addEventListener('DOMContentLoaded', () => {
            const tabsContainer = document.querySelector('.tabs');
            if (tabsContainer && window.innerWidth < 768) {
                let isDown = false;
                let startX;
                let scrollLeft;

                tabsContainer.addEventListener('mousedown', (e) => {
                    isDown = true;
                    tabsContainer.classList.add('active');
                    startX = e.pageX - tabsContainer.offsetLeft;
                    scrollLeft = tabsContainer.scrollLeft;
                });

                tabsContainer.addEventListener('mouseleave', () => {
                    isDown = false;
                    tabsContainer.classList.remove('active');
                });

                tabsContainer.addEventListener('mouseup', () => {
                    isDown = false;
                    tabsContainer.classList.remove('active');
                });

                tabsContainer.addEventListener('mousemove', (e) => {
                    if (!isDown) return;
                    e.preventDefault();
                    const x = e.pageX - tabsContainer.offsetLeft;
                    const walk = (x - startX) * 2;
                    tabsContainer.scrollLeft = scrollLeft - walk;
                });
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            // Re-trigger MathJax on resize
            if (window.MathJax) {
                MathJax.typesetPromise();
            }
        });

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            const activeTab = document.querySelector('.tab.active');
            if (!activeTab) return;

            const tabs = Array.from(document.querySelectorAll('.tab'));
            const currentIndex = tabs.indexOf(activeTab);

            if (e.key === 'ArrowLeft' && currentIndex > 0) {
                tabs[currentIndex - 1].click();
            } else if (e.key === 'ArrowRight' && currentIndex < tabs.length - 1) {
                tabs[currentIndex + 1].click();
            }
        });
    </script>

</body>

</html>